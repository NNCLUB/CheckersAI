<html lang="it">
<head> 
	<meta charset="UTF-8" />
	<meta name="description" content="Relazione riguardo al progetto per il corso di Intelligenza artificiale, AI checkers: Advanced Italo checkers" />
	<meta name="keywords" content="checkers, ai, ia, intelligenza artificiale, dama"/>  
	<meta name="author" content="Enrico Savoca, Stefano Campese" />
	<meta name="robot" content="index, follow" />
	<meta name="base" content="/" /> 
	<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">
	<link rel="stylesheet" type="text/css" href="css/bootstrap-theme.min.css">
    <link rel="stylesheet" type="text/css" href="css/other.css">
    <link rel="stylesheet" type="text/css" href="css/styles/darcula.css">
	<script src="js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<title> Checkers AI : Checkers Automaton Italo </title>
</head>
	<body>
	<header>
		<div class="container">
			<div class="title">
				<div class="col-sx-12">
					<img id="logo" src="css/logo.png" alt="logo unipd" />
				</div>
				<div class="col-sx-12">
					<h1 style="text-align:center">
						Progetto di intelligenza artificiale
					</h1>
				</div>
				<div class="col-sx-12">	
					<h2 style="text-align:center"> 
						Checkers AI : Checkers Automaton Italo
					</h2>
				</div>
				<div class="col-sx-12">
					<h5 style="text-align:center">
						Dedicato ad un damista che non c'è più
					</h5>
				</div>
			</div>	
		</div>
		
	</header>
	<main class="container"> 
	<section id="menu">
		<div class="row"> 
			<div class="col-sx-12">
				<h3>
					 	Indice: 
					 </h3> 
			</div>
			<div class="col-sx-12">
				 <ul>
				 	<li>
				 		<a href="#dama">
				 			1. La dama
				 		</a>
				 	</li>
					 <li>
						 <a href="#consuntivo">
							 2. Consuntivo orario
						 </a>
					 </li>
				 	<li>
				 		<a href="#progetto">
				 			3. Il progetto
				 		</a>
                        <ul>
                            <li>
                                <a href="#compilazEsecuz">
                                    3.1 Compilazione ed esecuzione del programma
                                </a>
                            </li>
                            <li>
                                <a href="#istruzioni">
                                    3.2 Istruzioni per giocare
                                </a>
                            </li>
                            <li>
                                <a href="#euristiche">
                                    3.3 Euristiche
                                </a>
                            </li>
                            <li>
                                <a href="#ottimizzazione">
                                    3.4 Ottimizzazione
                                </a>
                            </li>
                        </ul>
				 	</li>
                     <li>
                         <a href="#test">
                             4. Test
                         </a>
                         <ul>
                             <li>
                                 <a href="#tempi">
                                     4.1 Tempi medi di esecuzione
                                 </a>
                             </li>
                             <li>
                                 <a href="#partite">
                                     4.2 Partite tra giocatori di diversi livelli
                                 </a>
                             </li>
                             <li>
                                 <a href="#human">
                                     4.3 Partite tra giocatori umani e IA
                                 </a>
                             </li>
                         </ul>
                    </li>
				 	<li>
				 		<a href="#conclusioni">
				 			5. Conclusioni
				 		</a>
						 <ul>
							 <li>
								 <a href="#considerazioniEuristiche">
									 5.1 Considerazioni sulle euristiche
								 </a>
							 </li>
						 </ul>
				 	</li>
					 <li>
						 <a href="#fonti">
							 Appendice A: fonti
						 </a>
					 </li>
				 </ul>
			</div>	 
		</div>
		<hr>	 
	</section>
	<section id="dama">
		<h3>
			1. La dama
		</h3>
		<p>
			La dama è un gioco da tavolo tradizionale per due giocatori. I due giocatori, disposti ai lati opposti della scacchiera, muovono a turno i propri pezzi. Un giocatore ha i pezzi bianchi, l'altro quelli neri. Il giocatore con i pezzi neri inizia la partita facendo la prima mossa. I pezzi possono essere mossi solo di una casella in avanti, in diagonale: si muovono sulle caselle nere. Una pedina può mangiarne una dell'avversario scavalcandola diagonalmente; la pedina scavalcata ("mangiata"), viene rimossa dalla damiera. Quando una pedina raggiunge la riga più distante nella sua direzione di marcia, diventa dama. La dama si muove come una qualsiasi altra pedina, ma in qualsiasi direzione, sempre sulla diagonale. Esistono determinate varianti nazionali del gioco. La variante scelta per il progetto è quella inglese in cui ogni pedina, anche se dama, può essere catturata da ogni altra pedina. Tutte le pedine, comprese le dame, si muovono di una casella ad ogni turno. Se una pedina può essere mangiata in un turno, essa deve essere mangiata, inoltre è possibile concatenare le catture: se una pedina ha mangiato un'altra pedina nel suo turno e può ancora mangiare, allora deve farlo. Un giocatore perde quando non ha più pedine, perchè sono state tutte prese, o quando non può muoverne nessuna di quelle rimaste.
		</p>
		<a href="#menu">
			Torna all'indice
		</a>
		<hr>
	</section> <section id="consuntivo">
		<h3>
			2. Consuntivo orario
		</h3>
		<p>
			Nella seguente tabella sono riportate le ore di lavoro necessarie per la realizzazione delle componenti dell'intero progetto e per il raggiungimento degli obiettivi di progetto. Le ore comprendono quindi, non soltanto le ore utilizzate per l'implementazione di funzionalità nel programma sviluppato, ma anche quelle ore utilizzate per ricerca e per l'effettuazione dei test.
		</p>
		<table class="table">
			<caption>
				Consuntivo orario (in ore)
			</caption>
			<tr>
				<th>
					Lavoro svolto
				</th>
				<th>
					Autore
				</th>
				<th>
					Impegno orario
				</th>
				<th>
					Tipo di lavoro
				</th>
			</tr>
			<tr>
				<td>
					Progettazione, sviluppo componenti di base
				</td>
				<td>
					Enrico Savoca
				</td>
				<td>
					1+9
				</td>
				<td>
					Progettazione algoritmi, Implementazione funzionalità di base della dama (classi: Piece, Player, Spot, Board)
				</td>
			</tr>
			<tr>
				<td>
					Progettazione, sviluppo componenti di base
				</td>
				<td>
					Stefano Campese
				</td>
				<td>
					1+5
				</td>
				<td>
					Progettazione algoritmi, Implementazione funzionalità di base della dama (classi: King, Main)
				</td>
			</tr>
			<tr>
				<td>
					Sviluppo Minimax
				</td>
				<td>
					Enrico Savoca
				</td>
				<td>
					12
				</td>
				<td>
					Implementazione algoritmi Minimax (classi: MinimaxTree, Node)
				</td>
			</tr>
			<tr>
				<td>
					Pruning
				</td>
				<td>
					Enrico Savoca
				</td>
				<td>
					3
				</td>
				<td>
					Implementazione algoritmi di pruning (classi: MinimaxTree)
				</td>
			</tr>
			<tr>
				<td>
					Evaluation functions
				</td>
				<td>
					Stefano Campese
				</td>
				<td>
					14
				</td>
				<td>
					Ricerca e Implementazione algoritmi Evaluation Functions (classi: Evaluation)
				</td>
			</tr>
			<tr>
				<td>
					Ottimizzazione
				</td>
				<td>
					Stefano Campese
				</td>
				<td>
					2
				</td>
				<td>
					Implementazione Cache per i nodi del Minimax Tree (classi: MinimaxTree)
				</td>
			</tr>
			<tr>
				<td>
					Test
				</td>
				<td>
					Enrico Savoca
				</td>
				<td>
					2
				</td>
				<td>
					Esecuzione Test di analisi delle performance delle euristiche e dei diversi algoritmi
				</td>
			</tr>
			<tr>
				<td>
					Test
				</td>
				<td>
					Stefano Campese
				</td>
				<td>
					3
				</td>
				<td>
					Esecuzione Test di analisi delle performance delle euristiche e dei diversi algoritmi e raccolta dati
				</td>
			</tr>
			<tr>
				<td>
					Relazione, Presentazione
				</td>
				<td>
					Enrico Savoca
				</td>
				<td>
					3
				</td>
				<td>
					Stesura Relazione (sezioni: Dama, Progetto), Realizzazione Presentazione
				</td>
			</tr>
			<tr>
				<td>
					Relazione, Presentazione
				</td>
				<td>
					Stefano Campese
				</td>
				<td>
					5
				</td>
				<td>
					Stesura Relazione (sezioni: Consuntivo orario, Test, Conclusioni finali), Realizzazione Presentazione
				</td>
			</tr>
		</table>
		<a href="#menu">
			Torna all'indice
		</a>
		<hr>
	</section>
	<section id="progetto">
		<h3>
			3. Il progetto e i suoi scopi
		</h3>
		<p>
			Il progetto <span lang="en">Checkers AI</span> ha avuto come scopi principali la realizzazione di un'intelligenza artificiale che sapesse giocare in maniera discreta a dama e la sua analisi.
			Per l'implementazione del programma si è scelto Java e sono stati presi in considerazione una serie di programmi già realizzati, che implementavano il gioco della dama
			e in alcuni casi un'intelligenza artificiale. L'esempio di partenza scelto
			<a href="https://github.com/khaledalissa/simple-checkers">
		 	(link)
			</a>
			consiste nell'implementazione di una dama in cui i giocatori utilizzano 6 pedine a testa. Il gioco preso in esempio è una buona semplificazione del gioco della dama inglese, ma non è stato possibile
			riutilizzarlo a causa della qualità del codice. Nonostante questo, esso ha fornito un buon punto di partenza per capire in che modo sarebbe stato più sensato sviluppare il gioco della dama e
			quale flusso di esecuzione avrebbe dovuto seguire il programma. In un primo momento si è quindi trattato di implementare in toto il gioco della dama, includendo sia le sue regole e la sua logica, che
			l'aggiornamento della damiera visualizzata. Alla fine di ciò era possibile disputare partite tra due giocatori umani, che per giocare dovevano inserire a turno, come input, la mossa da far
			compiere alle proprie pedine. E' stato quindi sviluppato l'algoritmo di Minimax che poi è stato ottimizzato e completato con l'aggiunta di diverse funzioni di valutazione e di funzionalità come
			per esempio la possibilità di utilizzare il <span lang="en">pruning</span> su di esso.
		</p>
		<p>
			Dopo questa prima fase, prevalentemente di implementazione, si è passati all'analisi della bontà dell'algoritmo di intelligenza artificiale e delle funzioni di valutazione utilizzate.
			Sono state effettuate un grande nunmero di partite per verificare vari aspetti del programma. Prima di tutto la qualità dell'azione del <span lang="en">pruning</span>: per fare questo, si è scelto di usare
			un IA che faceva uso della funzione di valutazione 5 e che in alcune partite utilizzasse il <span lang="en">pruning</span> e in altre no. Più precisamente, per ogni profondità dell'albero,
			sono state disputate 10 partite con il suo utilizzo e 10 senza. Questo per verificare che impatto avesse l'utilizzo del <span lang="en">pruning</span> al crescere della dimensione
			dell'albero.
			In secondo luogo, sono state eseguite delle partite tra intelligenze artificiali che facevano uso di funzioni di valutazione diverse per verificare quale fosse la migliore.
			Infine sono state disputate delle partite in cui si confrontavano giocatori umani contro intelligenze artificiali che facevano uso delle diverse funzioni di valutazione.
			I risultati dei test sono riportati nella sezione 4 e discussi nella sezione 5.
		</p>
		<h4 id="compilazEsecuz">
			3.1 Compilazione ed esecuzione del programma programma
		</h4>
		<p>
		Il programma della dama è stato realizzato tramite il linguaggio di programmazione Java e può essere eseguito a seguito della sua compilazione. Per effettuarla è necessario aprire una finestra di terminale e spostarsi all'interno della cartella "src".
		Per generare i file contenenti il bytecode (.class) che possono essere eseguiti sulla Java Virtual Machine, si invocherà quindi il comando
		<pre class="java"><code>
		make
		</code></pre>
		Alla fine del processo, se non sono stati sollevati errori, sarà possibile avviare il programma attraverso il seguente input:
		<pre class="java"><code>
		java game.Main
		</code></pre>
		</p>
		<h4 id="istruzioni">
			3.2 Istruzioni per giocare
		</h4> 
		<p>
			Una volta avviata la partita si dovranno scegliere le caratteristiche dei due giocatori. Prima di tutto si chiederà se il giocatore che si sta creando è umano o
			se invece è comandato dalla CPU. Nel secondo caso, si dovrà specificare quindi quale tipo di euristica utilizzerà per compiere le sue scelte,
			che profondità avrà l'albero Minimax utilizzato e se si userà il Pruning sul suddetto albero. Creati i giocatori, il programma avvierà la partita ed il nero dovrà compiere la prima mossa.
			Ogni volta che verrà eseguita una mossa, essa verrà stampata e sarà seguita dalla stampa della scacchiera o damiera aggiornata.
			Le mosse accettate avranno una forma uguale alla seguente: "pedina mossa", dove pedina dovrà avere come valore il nome della pedina scelta dal giocatore, mentre mossa conterrà una delle seguenti stringhe:
			<ul>
				<li>
					moveRight : muovi a destra in avanti la pedina 
				</li>
				<li>
					moveLeft : muovi a sinistra in avanti la pedina
				</li>
				<li>
					moveDownRight : muovi a destra indietro la pedina (mossa consentita solo alle dame)
				</li>
				<li>
					moveDownLeft : muovi a sinistra indietro la pedina (mossa consentita solo alle dame)
				</li>
				<li>
					captureRight : la pedina cattura la pedina avversaria alla sua destra, in avanti
				</li>
				<li>
					captureLeft : la pedina cattura la pedina avversaria alla sua sinistra, in avanti
				</li>
				<li>
					captureDownRight la pedina cattura la pedina avversaria alla sua destra, indietro (mossa consentita solo alle dame)
				</li>
				<li>
					captureDownLeft la pedina cattura la pedina avversaria alla sua sinistra, indietro (mossa consentita solo alle dame)
				</li>
			</ul>
			Destra e sinistra, nelle mosse, sono assolute, relative alla scacchiera e non al suo orientamento rispetto al giocatore. Più semplicemente, una mossa a destra corrisponde ad un movimento verso la parte destra dello schermo. Lo stesso vale per la sinistra.
			Il gioco avrà fine quando uno dei giocatori non potrà effettuare più alcuna mossa o avrà finito le pedine. Si nominerà vincitore l'altro giocatore.  
		</p>
		<h4 id="euristiche">
			3.3 Euristiche
		</h4>
		<p>
			Le funzioni euristiche, sono funzioni che servono ad attribuire un <i>valore di utilit&agrave;</i> ai nodi che verranno scelti dall'algoritmo intelligente.<br>
			Nello sviluppo del progetto si &egrave; deciso di usare diverse euristiche, in modo da poter eseguire un maggior numero di sperimentazioni e test.<br><br>
			Prima di procedere con la spiegazione, &egrave; necessario specificare che le euristiche utilizzate, derivano da specifiche tencinche di gioco per la Dama, ciascuna delle quali prediligie un determinato aspetto (es: attacco, difesa...).<br><br>
			Tutte le funzioni sviluppate, hanno una base comune che serve a generare un valore di base per ogni nodo, il quale poi viene raffinato tramite applicazione di euristiche che corrispondono alle tecniche di gioco diverse, come citato in precedenza.

			<h5>Funzione 1: <i>Standard</i></h5>
			Questa eurisitca corrisponde alla funzione di base utilizzata da tutte le altre.<br>
			In questa funzione ogni pedina normale conta come 1, mentra ogni damone (King) ha un peso maggiore, che corrisponde ad un valore compreso tra  1.4 e 3, dipende se si gioca a <i>Dama Spagnola</i> o alla variante Italian ed Inglese.
		    Il fatto di dare un maggior peso ai damoni, serve ad incentivarne la genrazione e allo stesso tempo preservarne l'esistenza.<br><br>
			L'idea di base, è quella di considerare il numero di pezzi propri, meno il numero dei pezzi avversari, ritornando poi il valore della sottrazione come valore del nodo.
		    Questo approcio permette avere un intelligenza abbastaza bilanciata tra difesa ed attacco con degli ottimi risultati.<br>
			Vediamo ora un esempio:<br><br>


		<pre><code class="java">
	for(int i = 0; i <8; i++){
            for(int j = 0; j < 8; j++){
                if( board[i][j] != null && board[i][j].getOccupier() != null){

                    Piece piece = board[i][j].getOccupier();
                    if(piece.isKing()){

                        if(piece.isWhite()){
                            whiteKings += 1;
                        }
                        else{
                            blackKings += 1;
                        }
                    }
                    else{
                        if(piece.isWhite()){
                            white += 1;
                        }
                        else{
                            black += 1;
                        }
                    }
                }
            }
        }

        if(player.isWhite()){
            return (white-black + Evaluation.KINGS_EVAL*(whiteKings-blackKings));
        }
        else{
            //if black
            return (black - white + Evaluation.KINGS_EVAL*(blackKings-whiteKings));
        }

		</code></pre>

			Come si può vedere se il giocatore &egrave; bianco, la funzione ritorna la differenza tra bianchi e neri sommata alla differenza tra damoni bianchi e neri.<br>

			Questa euristica, come detto in precedenza, è molto bilanciata e riesce a battere euristiche sbilanciate con un media 48/70 partite vinte.<br>
			Questa funzione pu&ograve; essere utilizzata da sola, senza la necessit&agrave; di essere raffinata.

			<h5>Funzione 2: <i>Random</i></h5>
			Questa eurisitca corrisponde ad un'euristica <i>stupida</i>, questo perch&egrave; assegna valori casuali ai vari nodi<br>
			Questa funzione, risulta essere l'unica che non sfrutta la 1 come funzione di base da raffinare.

			Per assegnare pi&ugrave; valori casuali possibili si è scelto di ritornare valori tra 1 e 20:<br>

		<pre><code class="java">
			Random rand = new Random();
			Integer randomNum = rand.nextInt((20 - 1) + 1) + 1;
			return randomNum.floatValue();
		</code></pre>


			L'utilizzo di tale euristica ha portato ad interessanti osservazioni: In acluni casi si è osservato che tale euristica &egrave; riuscita a vincere il 20% delle partite con una media di 14 partite vinte su 70 giocate.
			Contro se stessa l'euristica arriva ad avere un 40% di vittorie.

		<h5>Funzione 3: <i>Centrality</i></h5>

		Questa euristica, chiamata anche <i>Centrality</i> ha come obbiettivo principale quello di spingere i propri pezzi a dominare il centro della scacchiera.
		Ogni mossa al centro della scacchiera è promossa ed incentivata.<br><br>
		Nello specifico, viene assegnato un valore maggiore a tutti quelli stati la cui mossa, prevede, uno spostamento verso il centro della scacchiera delle proprie pedine a discapito delle pedine avversarie.
		Allo stesso tempo, la funzione, penalizza le mosse che porterebbero l'avversario ad avere un numero maggiore di pedine nel centro.

		Il core della funzione &egrave;: <br><br>
		<pre class="java"><code>
		    float negative = 1;
                    float positive = 1;
                    if( Utils.isInCenter(i,j) ) {
                        negative = 10;
                        positive = 8;
                    }
                    else if(Utils.isInCenterRows(i)){
                        negative = 8;
                        positive = 6;
                    }
                    else if(Utils.isInCenterColumns(j)){
                        negative = 6;
                        positive = 4;
                    }
                    /* if piece is white and I want white */
                    if (piece.isWhite() && player.isWhite()) {
                        result += positive;
                    }
                    /* if piece is white and I want black */
                    else if (piece.isWhite() && player.isBlack()) {
                        result -= negative;
                    }
                    /* if piece is black and I want black */
                    else if (piece.isBlack() && player.isBlack()) {
                        result += positive;
                    }
                    /* if piece is black and I want white */
                    else {
                        result -= negative;
                    }
		</code></pre>

		Come si pu&ograve; notare l'euristica spinge molto sul controllo del centro scacchiera, che risulta essere una mossa molto buona, perch&egrave; spinge l'avversario verso il fondo, intrappolandolo.
		Putroppo questa euristica privilegia la parit&agrave; alla vittora, vincendo solo 21 partite su 70 giocate. Risulta essere discreta con euristiche offensive.
		Questa euristica, &egrave; stata usata in diversi test di Intelligenza Artificiale, come riportato nel paper: <a href="https://webdocs.cs.ualberta.ca/~jonathan/PREVIOUS/Papers/Papers/olympiad.ps">Reviving the game of checkers - Department of Computing Science Of Alberta Univerisity</a>, perch&egrave; risulta essere molto buona.


		<h5>Funzione 4: <i>Backrows</i></h5>
		Questa euristica, chiamata anche <i>Backrows</i>, ha come obbiettivo principale quello di spingere i propri pezzi a stare nell righe di testa e di fondo della scacchiera
		Ogni mossa al nel fondo i nella testa &egrave; incentivata, pi&ugrave; si &egrave; agli estremi, maggiore sar&agrave; sar&agrave; l'incentivo.<br><br>
		Nello specifico, viene assegnato un valore maggiore a tutti quelli stati la cui mossa, prevede, uno spostamento verso la propria linea di difesa o verso quella avversaria a dscapito delle pedine avversarie.
		Al contrario di 3, in questa funzione non si da peso alla centralit&agrave; perch&egrave; l'obbiettivo &egrave; quello di difendersi e di arrivare <i>dall'altra parte</i>.<br>
		Anche in questo caso, si penalizzano le mosse in cui sia l'avversario a prendere possesso di tali posizioni.<br>
		Il core dell'euristica &egrave; :<br><br>

		<pre class="java"><code>
		    float negative = 0;
                    float positive = 0;
                    if( Utils.isInBackrow(i)) {
                        negative = 10;
                        positive = 8;
                    }

                    else if (Utils.isInMiddleBackrow(i)){
                        negative = 8;
                        positive = 6;
                    }
                    /* if piece is white and I want white */
                    if (piece.isWhite() && player.isWhite()) {
                        result += positive;
                    }
                    /* if piece is white and I want black */
                    else if (piece.isWhite() && player.isBlack()) {

                        result -= negative;
                    }
                    /* if piece is black and I want black */
                    else if (piece.isBlack() && player.isBlack()) {

                        result += positive;
                    }
                    /* if piece is black and I want white */
                    else {

                        result -= negative;
                    }
		</code></pre>

		Come si pu&ograve; notare, l'euristica spinge molto sul fondo: pi&ugrave; si &egrave; vicini alle righe 0 o 7 maggiore sar&agrave; il valore.
		La funzione risulta essere la migliore di quelle studiate, perch&egrave; essendo sia molto difensiva che molto offensiva e riuscita a vincere un totale di 53 partite su 70.
		Questa euristica, &egrave; stata usata in diversi test di Intelligenza Artificiale, come riportato nel paper: <a href="https://webdocs.cs.ualberta.ca/~jonathan/PREVIOUS/Papers/Papers/olympiad.ps">Reviving the game of checkers - Department of Computing Science Of Alberta Univerisity</a>, perch&egrave; risulta essere molto buona.


		<h5>Funzione 5: <i>Complete</i></h5>
		Questa euristica, chiamata anche <i>Complete</i>, ha come obbiettivo principale quello valutare diversi fattori in modo da fare la scelta pi&ugrave; accurata.<br>
		Ogni mossa valuta se la pedina sta eseguendo una delle seguenti azioni:
		<ul>
			<li>Movimento verso il centro</li>
			<li>Movimento sui bordi</li>
			<li>Movimento verso un Damone</li>
		</ul>
		Il movimento verso il centro &egrave; molto incentivato, perchè come detto in 3, il posseso del centro della scacchiera tende a intrappolare l'avversario.<br>
		L'euristica incentiva anche il movimento verso i bordi, questo perch&egrave; rende le pedine pi&ugrave; sicure e difficilmente catturabili.<br>
		Ovvimante essendo un euristica completa tiene in consiederazione anche la vicinanza ai damoni (King), spingendo le pedine a starne alla larga, questo perch&egrave; un damone disponde di pi&ugrave; mosse possibili e quindi risulta essere pi&ugrave; pericoloso.<br>
		Questa funzione di valutazione risulta essere tendendente alla difensiva, tuttavia ha ottimi risultati in quanto tiene in considerazione diversi fattori e riesce a battare diverse euristiche.
		&Egrave; necessario sottolineare che in questo caso si tiene conto in modo marginale delle pedine avversarie col solo fine di raffinare ulteriormente la valutazionde dello stato.<br>
		Il core dell'euristica &egrave; :<br><br>
		<pre class="java"><code>
		     if (Utils.isInCenter(i, j)) {
                        positive = 5;
                        negative = 2;
                    }
                    if (Utils.isInEdge(j)) {
                        positive = 2;
                        negative = 1;
                    }
                    if(Utils.isNearKing(i, j, board, piece)){
                        positve_king = -3;
                        negative_king = 1;
                    }
                    /* if piece is white and I want white */
                    if (piece.isWhite() && player.isWhite()) {
                        result += positive;
                        result += positve_king;
                    }
                    /* if piece is white and I want black */
                    else if (piece.isWhite() && player.isBlack()) {
                        result -= negative;
                        result -= negative_king;
                    }
                    /* if piece is black and I want black */
                    else if (piece.isBlack() && player.isBlack()) {
                        result += positive;
                        result += positve_king;
                    }
                    /* if piece is black and I want white */
                    else {
                        result -= negative;
                        result -= negative_king;
                    }
		</code></pre>

		La funzione risulta essere tra le migliori di quelle studiate, perch&egrave; essendo molto completa riesce a vincere un totale di 35 partite su 70.
		Questa euristica, &egrave; stata usata in diversi test di Intelligenza Artificiale, come ad esempio nella tesi: <a href="http://tigerprints.clemson.edu/cgi/viewcontent.cgi?article=1074&context=all_theses">Soar Checkers - An Intelligent Checkers Playing - Jithu Menon - Clemson University</a>, perch&egrave; risulta essere molto buona e completa.


		<h5> Funzione 6: <i>Offensive</i> </h5>
		Questa euristica, chiamata anche <i>Offensive</i>, ha come obbiettivo principale di attaccare indipendentemente dal resto.<br>
		Ogni mossa valuta se la pedina si sta spostando nelle zone d'attacco della scacchiere e/o sta per mangiare una pedina avversaria.
		Nello specifico, pi&ugrave; in attacco si sta spostando la pedina, maggiore sarà il valore dello stato.
		Il punteggio massimo viene assegnato se la mossa che la pedina sta per eseguire &egrave; un <i>capture</i>, ovvero se sta per mangiare una pedina avversaria.<br><br>
		Come detto prima, questa euristica non si cura dell'avversario, e il suo unico scopo &egrave; <i>spingersi in avanti e mangiare</i><br>

		Il core dell'erusitica &egrave;:

		<pre class="java"><code>
		      if (player.isWhite() && piece.isWhite()) {

                        if(Utils.isInMiddleSide(i)){

                            result += 2;
                        }

                        if(Utils.isInHighSide(i)){
                            result += 5;
                        }

                        if(node.getMove().contains("capture")){

                            result += 7;
                        }


                    } else if(player.isBlack() && piece.isBlack()) {

                        if(Utils.isInMiddleSide(i)){

                            result += 2;
                        }

                        if(Utils.isInLowerSide(i)){
                            result += 5;
                        }

                        if(node.getMove().contains("capture")){

                            result += 7;
                        }
                    }
		</code></pre>

		La funzione risulta essere buona e discreta in attacco, tuttavia "attacando con il paraocchi" non tiene conto della difesa e quindi riesce a vincere solo un totale di  24 partite su 70.
		Questa euristica è stata presa utilizzando come spunto un <i>assignment</i> della New York University reperibile a questo link: <a href="http://cs.nyu.edu/courses/spring12/CSCI-UA.0472-001/checkers2.pdf">Checkers 2</a>
		Dai test eseguiti questa euristica risulta essere valida contro euristiche basilari e/o bilanciate, mentre, contro euristiche pi&ugrave; difensive, risulta piuttosto inefficace.

		<h5> Funzione 7: <i>Defensive</i> </h5>
		Questa euristica, chiamata anche <i>Defensive</i>, ha come obbiettivo principale di difendersi indipendentemente dal resto.<br>
		Ogni mossa valuta se la pedina si sta spostando in una zona protetta e difesa o se si sta spostando in una zona neutra o non protetta.
		Nello specifico, pi&ugrave; protetta sar&agrave; la pedina, maggiore sarà il valore dello stato.<br>
		Prima di procedere, &egrave; necessario spiegare cosa si intende per zona difesa. Per zona difesa si intende una zona in cui la pedina sia <i>coperta</i> da una coppia di pedine, o da una pedina singola, in modo che l'avversario non possa attaccare.<br><br>
		Ovvimante, essere coperti da una coppia di pedine da una difesa migliore rispetto alla copertura fatta da una pedina singola, quindi il valore assegnato sar&agrave; maggiore.
		C'&egrave; da aggiungere che vengono penalizzate le mosse in cui le pedine si spostano vicino a uno o pi&ugrave; avversari; maggiore &egrave; il numero di avversari a cui la pedina si avvicina, peggiore sar&agrave; il punteggio assegnato.
		Il core della funzione &egrave; :<br>

		<pre class="java"><code>
		      if (player.isWhite() && piece.isWhite()) {

                       if(Utils.isNearOneWhite(i,j,board)){

                           result += 1;
                       }
                       else if(Utils.isNearMoreThanOneWhite(i,j,board)){

                           result += 2;
                       }
                       else if(Utils.isNearOneOpponent(i,j,board,piece)){

                           result -= 2;

                       }
                       else if(Utils.isNearMoreThanOneOpponent(i,j,board,piece)){
                           result -= 3;
                       }


                    } else if(player.isBlack() && piece.isBlack()) {


                        if(Utils.isNearOneBlack(i,j,board)){
                            result += 1;
                        }

                        if(Utils.isNearMoreThanOneBlack(i,j,board)){
                            result += 2;
                        }
                        else if(Utils.isNearOneOpponent(i,j,board,piece)){

                            result -= 2;

                        }
                        else if(Utils.isNearMoreThanOneOpponent(i,j,board,piece)){
                            result -= 3;
                        }

                    }
		</code></pre>
		La funzione risulta essere buona e molto forte in difesa, nonostante sia una tecnica difensiva riesce a vincere il totale di 37 partite su 70.
		Questa euristica è stata presa utilizzando come spunto un <i>assignment</i> della New York University reperibile a questo link: <a href="http://cs.nyu.edu/courses/spring12/CSCI-UA.0472-001/checkers2.pdf">Checkers 2</a>

		<h5>Funzione 8: <i>Kings Forcing</i></h5>
		Questa euristica, chiamata anche <i>Kings Forcing</i>, ha come obbiettivo principale quello di muovere i damoni spostandoli verso il centro per attaccare.<br>
		Ogni mossa valuta se la damona si sta spostando in una zona centrale della scacchiera, se si sta per attaccare se ci si sta spostando verso un damone e se ci si sta allontanando dagli angoli o i bordi della scacchiera.<br>
		Nello specifico, pi&ugrave; il damone si sposter&agrave; verso il centro o tenter&agrave; di attaccare, maggiore sarà il valore dello stato.<br>Se invece lo stato prevede che il damone venga spostato in pozioni defilate, come bordi o angoli allora verr&agrave; penalizzato.

		Questa euristica viene usata come <i>rinforzo</i> poich&egrave;, spesso, nelle partite si rischia di arrivare a delle situazioni di stallo che possono essere risolte tramite la forzatura ad attaccare.<br>
		Il core di questa funzione &egrave; :

		<pre class="java"><code>
		      if(piece.isKing()) {


                        if (Utils.isNearMoreThanOneOpponent(i,j,board,piece)) {

                            result += 5;
                        }

                        if (Utils.isNearOneOpponent(i,j,board,piece)) {

                            result += 7;
                        }

                        if (Utils.isInCenter(i, j)) {

                            result += 7;
                        }

                        if(node.getMove().contains("capture")){

                            result += 15;
                        }

                        if (Utils.isInEdge(j)) {

                            result -= 4;
                        }

                        if (Utils.isInBackrowByColor(i, piece)) {

                            result -= 7;
                        }

                        if (Utils.isInAngle(i, j)) {

                            result -= 10;
                        }
                    }
                    else{
                        if(node.getMove().contains("capture")){

                            result += 10;
                        }
                    }
		</code></pre>

		Come sin pu&ograve; notare questa euristica spinge molto sul movimento dei damoni e predilige, in genere, l'attacco; oltre a ci&ograve; questa euristica da un peso maggiore ai damoni, e quindi ne incentiva la creazione.
		Questa euristica &egrave; stata creata tramite un attento studio della situazione, prendendo il considerazione il fatto che, durante le fasi finali di una partita, il numero di damoni &egrave; maggiore e quindi &egrave; necessario agire su di essi per riforzare le euristiche normali.






		</p>

		<h4 id="ottimizzazione">
			3.4 Ottimizzazione
		</h4>
		<p>
			Durante lo sviluppo del progetto ci siamo trovati in difficolt&agrave; a causa dell'utilizzo massiccio di memoria degli algoritmi.<br>
			In generale l'algoritmo MinMax soffre dello stesso problema delle ricerche in profondit&agrave; e ampiezza: l'utilizzo di memoria.<br><br>
			Per far fronte a tale problema esistono diverse tecniche come ad esempio:
			<ul>
				<li>Ricerca di Quiescenza</li>
				<li>Memoization</li>
			</ul>

		La ricerca di quiescenza, &egrave; una tecninca che permette all'algoritmo di <i>tagliare</i> la ricerca quando, la funzione di valutazione, per una serie di nodi non cambia di molto, ovvero quando il valore di un set di nodi oscilla in un certo range deciso a priori.
		Questa tecnica &egrave; molto utilizzata e permette di risparmiare memoria che pu&ograve; essere utilizzata nei passi succcessivi per scoprire nodi pi&ugrave; promettenti.
		Tuttavia la nostra scelta non &egrave; ricaduta su questa tecnnica, perchè avrebbe notevolmente aumentato la complessit&agrave; del codice e soprattutto, per come e&grave; stata progettata l'intelligenza, non avrebbe portato gradni benefici<br><br>

		La memoization, &egrave; una tecninca che permette all'algoritmo di risparmiare memoria andando a creare un <i>hashtable</i> in cui salvare i nodi generati, in modo tale da riutilizzare uno stesso nodo invece di crearne uno di nuovo.
		Nello specifico, ogni qualvolta viene costruito l'albero di ricerca, si va a controllare se il nodo che sta per essere creato esiste gi&agrave; o se invece deve essere creato da zero. Nel caso in cui questo esista gi&agrave; allora viene utilizzato, evitando di crearne uno nuovo e quindi risparmiando memoria.

		Nel progetto, per attuare questa tecnica abbiamo deciso di creare, come gi&agrave; detto, una <i>hashtable</i> la cui chiave, per poter essere univoca per ongi nodo generato, &egrave; data dall'hasing di diversi parametri:
		<ul>
			<li>Nome del pezzo</li>
			<li>Mossa</li>
			<li>Padre</li>
			<li>Profondit&agrave;</li>
			<li>Giocatore che esegue la mossa</li>
			<li>Stato della scacchiera</li>
		</ul>

		L'unione di questi campi crea una chiave univoca che corrisponde solo ad un possibile nodo perchè dipende dallo  anche dallo stato e dalla scacchiera.<br>
		Nello specifico il codice che questo &egrave;:<br>

		<pre class="java"><code>
	Integer hash = Objects.hash(piece.getName() +" "+ move, father, depth, copyOfPlayer, copyOfBoard);
        if(MiniMaxTree.cache.containsKey(hash)){
            tmp =  MiniMaxTree.cache.get(hash);
        }else{
            tmp = new Node(piece.getName() +" "+ move, father, depth, copyOfPlayer, copyOfBoard);
        }
		</code></pre>

		Questa ottimizzazione risulta essere vantaggiosa. Se avessimo usato una cache persistente, come ad esempio una cache Redis o Memcache, le prestazioni sarebbero ulteriormente incrementate, poiech&egrave; sarebbe come avere un database con tutte le possibili mosse.<br><br>
		Un altra considerazione da fare potrebbe essere quella di aggiungere un fattore <i>giovinezza</i> ai nodi presenti nella cache, in modo da eliminare quei nodi che sono presenti da molto tempo e che difficilmente saranno utilizzati.<br><br>
		Molto importante e spiegare come, al fine di massimizzare l'efficenza computazionale, nelle funzioni euristiche che usano come base la 1, si &egrave; scelto di duplicare il codice.<br>
		La causa principale risiede nei cicli <i>for</i>, che permettono la scansione della scacchiera. La duplicazione del codice ha permesso di evitare l'esecuzione doppia dei cilci for, ottimizzando le prestazioni.<br><br>

		L'intenzione comunque e quella di rilasciare, in futuro, ulteriori versioni del progetto, che possano usare diverse ottimizzazioni.
		</p>
		<a href="#menu">
			Torna all'indice
		</a>
		<hr>
	</section> 
	<section id="test">
		<h3>
			4. Test
		</h3>
		<p>
			Sono stati eseguiti due tipi di test. Il primo tipo di test consisteva nella misurazione e raccolta dei tempi medi necesari per eseguire una mossa, in una partita, tramite l'uso di un albero di decisione Minimax con pruning e senza. Il secondo tipo di test ha richiesto l'esecuzione di un grande numero di partite in cui si sono confrontati diversi tipi di giocatori: comandati dalla CPU (con euristiche più o meno buone) e persone.
		</p>
		<h4 id="tempi">
			4.1 Tempi medi di esecuzione
		</h4>
		<p>
			Come anticipato nella sezione precedente, il primo test effettuato ha avuto come scopo quello di verificare la qualità del <span lang="en">pruning</span>. In particolare, verificare in che modo
			il suo utilizzo diminuisce la complessità computazionale. Per questo test sono state effettuatue una serie di test, tenendo come costante l'euristica e cambiando il resto delle variabili.
			Ogni partita ha avuto come giocatore costante, un'intelligenza artificiale che facesse uso della funzione di valutazione 5. Per ogni diversa profondità dell'albero da esso utilizzato, sono
			state disputate 20 diverse partite, ognuna contro giocatori diversi; 10 partite sono state giocate da un'intelligenza che facesse uso del pruning e 10 da una che non lo utilizzasse. Sono stati
			registrati i tempi medi richiesti per ogni mossa in ogni partita e si è calcolata infine una media dei tempi richiesti alle diverse profondità. La tabella seguente mostra i risultati ottenuti.
		</p>
		<table class="table">
			<caption>
				Tempi medi per mossa, in millisecondi, a diverse prodondità
			</caption>
			<tr>
				<th>
					Profondità
				</th>
				<th>
					con Pruning (ms)
				</th>
				<th>
					senza Pruning (ms)
				</th>
            </tr>
			<tr>
				<td>
					2
				</td>
				<td>
					1,11
				</td>
				<td>
					1,52
				</td>
			</tr>
			<tr>
				<td>
					3
				</td>
				<td>
					4,80
				</td>
				<td>
					4,90
				</td>
			</tr>
			<tr>
				<td>
					4
				</td>
				<td>
					11,34
				</td>
				<td>
					11,83
				</td>
			</tr>
			<tr>
				<td>
					5
				</td>
				<td>
					35,32
				</td>
				<td>
					28,85
				</td>
			</tr>
			<tr>
				<td>
					6
				</td>
				<td>
					152,56
				</td>
				<td>
					120,66
				</td>
			</tr>
			<tr>
				<td>
					7
				</td>
				<td>
					1461,85
				</td>
				<td>
					1034,85
				</td>
			</tr>
			<tr>
				<td>
					8
				</td>
				<td>
					4892,64
				</td>
				<td>
					3386,58
				</td>
			</tr>
		</table>  
		<h4 id="partite">
			4.2 Partite tra giocatori di diversi livelli
		</h4>
		<p>
			In seguito al primo test, sono state disputate un buon numero di partite tra IA che utilizzassero funzioni di valutazione diverse, con un albero Minimax di profondità 7. Per ogni combinazione
			di giocatori, sono state effettuate più partite, con lo scopo di verificare quale funzione riportasse risultati migliore e quindi un maggior numero di vittorie.
			Nella tabella sottostante sono riportati i risultati delle partite. La tabella dev'essere letta nel seguente modo: il contenuto di ogni casella
			consiste nel numero di partite vinte (in percentuale) dal giocatore in colonna, contro quello in riga.
		</p>
		<table class="table">
			<caption>
				Partite disputate, % vittorie
			</caption>
			<tr>
				<th>
					VS (num. Vittorie / num. Partite)
				</th>
				<th>
					(1), Standard
				</th>
				<th>
					(2)
				</th>				
				<th>
					(3)
				</th>
				<th>
					(4)
				</th>
				<th>
					(5)
				</th>				
				<th>
					(6)
				</th>
				<th>
					(7)
				</th>
			<tr>
				<td>
					(1)
				</td> 
				<td>
					100%
				</td>
				<td>
					20%
				</td>
				<td>
					0%
				</td>
				<td>
					50%
				</td>  
				<td>
					100%
				</td>
				<td>
					0%
				</td>
				<td>
					0%
				</td>
			</tr> 
			<tr>
				<td>
					(2)
				</td>
				<td>
					80%
				</td>
				<td>
					40%
				</td>
				<td>
					60%
				</td>
				<td>
					40%
				</td>
				<td>
					50%
				</td>
				<td>
					40%
				</td>
				<td>
					20%
				</td>
			</tr> 
			<tr>
				<td>
					(3)
				</td>
				<td>
					100%
				</td>
				<td>
					20%
				</td>
				<td>
					100%
				</td>
				<td>
					100%
				</td>
				<td>
					pari
				</td>
				<td>
					50%
				</td>
				<td>
					pari
				</td>
			</tr> 
			<tr>
				<td>
					(4)
				</td>
				<td>
					50%
				</td>
				<td>
					0%
				</td>
				<td>
					0%
				</td>
				<td>
					100%
				</td>
				<td>
					50%
				</td>
				<td>
					50%
				</td>
				<td>
					100%
				</td>
			</tr> 
			<tr>
				<td>
					(5)
				</td>
				<td>
					0%
				</td>
				<td>
					20%
				</td>
				<td>
					pari
				</td>
				<td>
					50%
				</td>
				<td>
					100%
				</td>
				<td>
					pari
				</td>
				<td>
					50%
				</td>
			</tr> 
			<tr>
				<td>
					(6)
				</td>
				<td>
					100%
				</td>
				<td>
					20%
				</td>
				<td>
					50%
				</td>
				<td>
					50%
				</td>
				<td>
					pari
				</td>
				<td>
					100%
				</td>
				<td>
					100%
				</td>
			</tr> 
			<tr>
				<td>
					(7)
				</td>
				<td>
					50%
				</td>
				<td>
					20%
				</td>
				<td>
					pari
				</td>
				<td>
					0%
				</td>
				<td>
					50%
				</td>
				<td>
					0%
				</td>
				<td>
					100%
				</td>
			</tr>
			<tr>
				<td>
					Media vittorie:
				</td>
				<td>
					48/70
				</td>
				<td>
					14/70
				</td>
				<td>
					21/70
				</td>
				<td>
					53/70
				</td>
				<td>
					35/70
				</td>
				<td>
					24/70
				</td>
				<td>
					37/70
				</td>
			</tr>
		</table>
        <h4 id="human">
            4.3 Partite tra giocatori umani e IA
        </h4>
		<p>
			Il terzo test aveva come scopo quello di verificare quanto buone fossero le funzioni di valutazioni applicate all'interno di partite contro giocatori umani.
			Sono stati scelti 3 diversi giocatori umani:
			<ul>
				<li>
					1 dilettante, che non utilizza alcuna strategia: cerca di non farsi mangiare le pedine, commette saltuariamente errori;
				</li>
				<li>
					1 esperto, che gioca sulla difensiva e cerca di evitare che le proprie pedine vengano mangiate;
				</li>
				<li>
					1 esperto, che gioca sull'attacco e punta su diverse strategie: fornisce esche per poi mangiare qualche pedina in più dell'avversario e fare dama.
				</li>
			</ul>
			Ogni giocatore ha disputato una partita contro ogni IA e ogni IA utilizzava per ogni partita una funzione di valutazione diversa e un albero Minimax con profondità costante 6.
			Premettendo che le partite sono state vinte tutte dai giocatori umani, e del perchè se ne discuterà nelle conclusioni, per ogni partita ne è stata registrata la sua durata, in turni.
		</p>
        <table class="table">
            <caption>
                Percentuale vittorie nelle partite tra giocatori umani e IA
            </caption>
            <tr>
                <th>
                    Euristiche:
                </th>
                <th>
                    1
                </th>
                <th>
                    2
                </th>
                <th>
                    3
                </th>
                <th>
                    4
                </th>
                <th>
                    5
                </th>
                <th>
                    6
                </th>
                <th>
                    7
                </th>
            </tr>
            <tr>
                <td>
                    Giocatore dilettante
                </td>
                <td>
					87
                </td>
                <td>
					34
                </td>
                <td>
					41
                </td>
                <td>
					92
                </td>
                <td>
					58
                </td>
                <td>
					42
                </td>
				<td>
					91
				</td>
            </tr>
			<tr>
				<td>
					Giocatore esperto (difensivo-backrows)
				</td>
				<td>
					92
				</td>
				<td>
					33
				</td>
				<td>
					50
				</td>
				<td>
					74
				</td>
				<td>
					75
				</td>
				<td>
					39
				</td>
				<td>
					96
				</td>
			</tr>
            <tr>
                <td>
                    Giocatore esperto (attaccante-strategico)
                </td>
                <td>
					42
                </td>
                <td>
					42
                </td>
                <td>
					38
                </td>
                <td>
					88
                </td>
                <td>
					62
                </td>
                <td>
					53
                </td>
				<td>
					48
				</td>
            </tr>
            <tr>
                <td>
					Media:
                </td>
                <td>
					74
                </td>
                <td>
					36
                </td>
                <td>
					43
                </td>
                <td>
					85
                </td>
                <td>
					65
                </td>
                <td>
					45
                </td>
				<td>
					78
				</td>
            </tr>
        </table>
		<a href="#menu">
			Torna all'indice
		</a>
		<hr>
	</section> 	
	<section id="conclusioni">
		<h3>
			5. Conclusioni
		</h3>
		<p>
		</p>
		<h4 id="considerazioniEuristiche">
		5.1 Considerazioni sulle euristiche
	</h4>
		<p>
			Queste euristiche sono tutte derivate da tecniche di gioco del mondo reale, e spesso sono tecniche studiate appostitamente per creare Intelligenze Artificiali pi&ugrave; performanti.
			In genere, tali funzioni, vengono spesso usate contemporaneamente, in modo da tenere conto di pi&ugrave; variabili ed avere una maggior Intelligenza.<br><br>
			E&grave; molto interessante osservare come l'euristica <i>Randomize</i> abbia risultati inaspettati. Essendo per definizione una euristica che <i>fa mosse casuali</i> tendenzialmente non dovrebbe avere molto successo.
			Dai nostri test, tuttavia, &egrave; emerso che, in media, tale euristica vince il 20% delle partite arrivando al 40% nel caso affronti se stessa.<br>
			E&grave; ulteriormente interessante osservare che in molti casi l'euristica &egrave; riescita anche a paraggiare.
		</p>
		<a href="#menu">
			Torna all'indice
		</a>
		<hr>
	</section>
	<section id="fonti">
		<h3>
			Appendice A: fonti
		</h3>
		<p>
			<ul>
				<li>
					Slide sui giochi del professore A. Sperduti:
					<a href="http://www.math.unipd.it/~sperduti/AI15/giochi.pdf">
						http://www.math.unipd.it/~sperduti/AI15/giochi.pdf
					</a>
				</li>
				<li>
					Libro di testo:
					<a href="http://aima.cs.berkeley.edu/index.html">
						S. Russell & P. Norvig, "Artificial Intelligence: A Modern Approach", Prentice Hall, terza edizione, 2010
					</a>
				</li>


				<li>
					L'implementazione della dama presa come punto di partenza:
					<a href="https://github.com/khaledalissa/simple-checkers">
					https://github.com/khaledalissa/simple-checkers
					</a>

				</li>
			</ul>
		</p>
		<a href="#menu">
			Torna all'indice
		</a>
		<hr>
	</section>
	</main>
	</body>
</html>